#!/usr/bin/perl -w
#
# socksredirect: 
#   iptables -t nat -A OUTPUT -p tcp ! -d localnetwork -j REDIERCT --to-ports 1234
#   socksredirect 1234 address_of_socks_server [user passoword]
#  
#   Uses /proc/net/nf_conntrack to restore destination address and port
#
# Copyright (c) 2009 Vitaly "_Vi" Shukela. Some rights reserved.
# 
#

my $rcsid = ''; $rcsid .= '$Id:$';

use strict;
use Socket;

my $addresstolisten=shift;
my $porttolisten=shift;
my $addresstoconnect=shift;
my $porttoconnect=shift;
die("Usage: socksredirect address_to_listen port_to_listen address_of_socks_server [user password [oneround]]\nPreparation: iptables -t nat -A OUTPUT -p tcp -d destination_to_be_socksified -j REDIERCT --to-ports port_to_listen\n") unless $porttoconnect;
my $user=shift;
my $password=shift;
my $mode=shift||"";

sub SIGPIPE {
    # just ignore it. The writer will handle.
    print STDERR "SIGPIPE!\n";
    $SIG{PIPE}=\&SIGPIPE;
}
$SIG{PIPE}=\&SIGPIPE;


socket(SS, AF_INET, SOCK_STREAM, 0)  or die "socket: $!";

setsockopt(SS, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))   or die "setsockopt: $!";

#INADDR_ANY
bind(SS, sockaddr_in($porttolisten, inet_aton($addresstolisten))) or die "bind: $!";

listen(SS,0) or die "listen: $!";

my %portmap;
my %socksinfo;

my $rin = my $win = my $ein = '';
vec($rin,fileno(SS),1) = 1;

sub establishsocks_init($);
sub establishsocks_oneround($);

for(;;){
    my $nfound;
    $nfound = select(my $rout=$rin, undef, undef, undef);

    my $buffer;
    my $readsock;
    my $writesock;
    my $readret;
    my $writeret;
    my $offset;

    die("select: $!") if $nfound==-1;
    
    if(vec($rout,fileno(SS),1)){
	my $s;
	my $paddr = accept($s, SS);
	my($port,$iaddr) = sockaddr_in($paddr);

	my $srcip = inet_ntoa($iaddr);
	my $srcport = $port;

        print STDOUT "$srcip:$port -> ";

	my $destip;
	my $destport;

        open F, "</proc/net/nf_conntrack";
	while(<F>) {
	    /src=$srcip dst=([0-9.]+) sport=$srcport dport=(\d+)/ and $destip=$1 and $destport=$2;
	}
	close F;

	unless($destip and $destport) {
	    print STDOUT "NULL?\n";
	    print $s "Sorry, this port is intended to be connected using conntrack\n";
	    close $s;
	} else {
	    print STDOUT "$destip:$destport\n";

	    my $so;
	    socket($so, AF_INET, SOCK_STREAM, 0) or $so=undef;
	    if($so && connect($so, sockaddr_in($porttoconnect, inet_aton($addresstoconnect)))) {
		select $so; $|=1;
		my $si = { 
		    soaddr=>$addresstoconnect, 
		    soport=>$porttoconnect, 
		    souser=>$user, 
		    sopassword=>$password, 
		    srcip=>$srcip,
		    srcport=>$srcport,
		    destip=>$destip, 
		    destport=>$destport,
		    peer=>$s,
		    so=>$so,
		    state=>($mode eq "oneround")?\&establishsocks_init_oneround:\&establishsocks_init,
		    errortext=>"",
		    bindip=>"",
		    bindport=>"",
		};
		
		$si->{state}($si);  # Call establishsocks_init
		$socksinfo{fileno($so)}=$si;
		vec($rin, fileno($so), 1)=1;

		if($si->{oneround}) {
		    # Setup sending end to enable early request transmission
		    vec($rin, fileno($s), 1)=1;
		    $portmap{fileno($s)}=$so;
		    $portmap{fileno($so)}=$s;
		}
		# wait for reply from SOCKS server, serving other requests

	    } else {
		print $s "Error: Unable to establish connection to SOCSK5 $addresstoconnect:$porttoconnect\n";
		print STDERR "Unable to establish connection to SOCSK5 $addresstoconnect:$porttoconnect\n";
		close $s;
	    }
	}
    }
    
    # look for not yet negotiated SOCKS connections
    foreach my $i (keys %socksinfo) {
	if(vec($rout,$i,1)) {
	    my $si = $socksinfo{$i};

	    # Continue negotiation with SOCKS5
	    $si->{state}($si); # Next move
		
	    my $peer = $si->{peer};
	    my $so = $si->{so};
		
	    if($si->{errortext}) {
		print STDOUT "    $si->{srcip}:$si->{srcport} -> $si->{destip}:$si->{destport} ($si->{errortext})\n";  
		print $peer "Error: $si->{errortext}\n";
		vec($rin, fileno($so), 1)=0;
		delete $socksinfo{fileno($so)}; # Stop SOCKS negotiation phase
		close $so;
		close $peer;
		next;
	    }

	    unless(defined $si->{state}) { 
		# success, rewiring it to pormapper
		print STDOUT "    $si->{srcip}:$si->{srcport} -> $si->{destip}:$si->{destport} ($si->{bindip}:$si->{bindport})\n";  
		$portmap{fileno($peer)}=$so;
		$portmap{fileno($so)}=$peer;
		vec($rin, fileno($peer), 1)=1; # Begin receiving data from user
		vec($rout, fileno($so), 1)=0; # Do not read data from SOCKS server without selecting it
		delete $socksinfo{$i}; # Stop SOCKS negotiation phase
		next;
	    }  

	    # Next phase of SOCKS connection
	    # Server other things while waiting for it
	}
    }

    # Looks for portmappers (already negotiated with SOCKS server)
    foreach my $i (keys %portmap) {
	next if exists $socksinfo{$i}; # avoid sending to clients negotiation requests from SOCKS server (oneround mode)
	if(vec($rout,$i,1)) {
	    my $writesock     = $portmap{$i};
	    my $readsock      = $portmap{fileno($writesock)};
	    unless (fileno($readsock)==$i) {
		print STDERR "Assertion failed: portmap is not paired?\n";
	    }
	    $readret = sysread $readsock, $buffer, 1024;
	    $offset=0;
	    if($readret) {
		while ($readret) {
		    $writeret = syswrite $writesock, $buffer, $readret, $offset;
		    unless($writeret) {
			# Error. Shutting down socket
			vec($rin,fileno($readsock),1)=0;
			vec($rin,fileno($writesock),1)=0;
			delete $portmap{fileno($writesock)};
			delete $portmap{fileno($readsock)};
			shutdown($readsock, 2);
			shutdown($writesock, 2);
			close $readsock;
			close $writesock;
			last;    
		    }
		    $readret-=$writeret;
		    $offset+=$writeret;
		}
	    } else {
		# Shutdown this way
		vec($rin,fileno($readsock),1)=0;
		shutdown($readsock, 0);
		shutdown($writesock, 1);
		unless (vec($rin,fileno($writesock),1)) {
		    # close filehandles
		    delete $portmap{fileno($writesock)};
		    delete $portmap{fileno($readsock)};
		    close $readsock;
		    close $writesock;
		}
	    }
	}
    }
}

sub es_noauth($);
sub es_userauth($);
sub es_userauth_recv($);
sub es_readytosend($);
sub es_finalizing($);

sub establishsocks_init($) {
    my $self = shift;
    my $so = $self->{so};
    
    $self->{oneround}=0;
    unless ($self->{souser}) {
	print $so pack("CCC", 5, 1, 0);
        $self->{state} = \&es_noauth;
    } else {
	print $so pack("CCC", 5, 1, 2);
	$self->{state} = \&es_userauth;
    }
}

sub es_noauth($) {
    my $self = shift;
    my $so = $self->{so};
    my $buf;

    read $so, $buf, 2;
    my ($ver, $method) = unpack "CC", $buf;
    $ver = -1 unless defined $ver;
    unless($ver==5) {
	$self->{errortext} = "socks version $ver? (should be 5 - SOCKS5)";
	return;
    }
    $method = "EOF" unless defined $ver;
    unless($method==0) {
	$self->{errortext} = "auth method $method? (should be 0 - noauth)";
	return;
    }
    return es_readytosend($self);
}

sub es_userauth($) {
    my $self = shift;
    my $so = $self->{so};
    my $buf;    
    my $user = $self->{souser};
    my $password = $self->{sopassword};


    read $so, $buf, 2;
    my ($ver, $method) = unpack "CC", $buf;
    $ver = -1 unless defined $ver;
    unless($ver==5) {
	$self->{errortext} = "socks version $ver? (should be 5)";
	return;
    }
    $method = -1 unless defined $ver;
    unless($method==2) {
	$self->{errortext} = "auth method $method? (should be 2 - username/password)";
	return;
    }
    
    unless($self->{oneround}) {
	print $so pack("CC", 1, length($user)) . $user . pack("C", length($password)) . $password;
    }

    $self->{state} = \&es_userauth_recv;
}
 
sub es_userauth_recv($) {
    my $self = shift;
    my $so = $self->{so};
    my $buf;

    read $so, $buf, 2;
    my ($authver, $status) = unpack "CC", $buf;
    $authver = -1 unless defined $authver;
    unless($authver==1) {
	$self->{errortext} = "auth version $authver? (should be 1)";
	return;
    }
    $status = -1 unless defined $status;
    unless($status==0) {
	$self->{errortext} = "SOCKS5 authentication failed";
	return;
    }
    return es_readytosend($self);
}         

sub es_readytosend($) {
    my $self = shift;
    my $so = $self->{so};

=cut
        +----+-----+-------+------+----------+----------+
        |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
        +----+-----+-------+------+----------+----------+
        | 1  |  1  | X'00' |  1   | Variable |    2     |
        +----+-----+-------+------+----------+----------+
=cut

    unless($self->{oneround}) {
	print $so pack("CCCC", 5, 1, 0, 1).inet_aton($self->{destip}).pack("n", $self->{destport});
    }
    $self->{state} = \&es_finalizing;
}

sub es_finalizing($) {
    my $self = shift;
    my $so = $self->{so}; 
    my $buf;

=cut
        +----+-----+-------+------+----------+----------+
        |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
        +----+-----+-------+------+----------+----------+
        | 1  |  1  | X'00' |  1   | Variable |    2     |
        +----+-----+-------+------+----------+----------+
=cut

    read $so, $buf, 10;
    my ($ver, $rep, $rsv, $atyp, $bnd, $bndp) = unpack "CCCCLn", $buf;
    $ver = -1 unless defined $ver;  $rep = -1 unless defined $rep; $atyp = -1 unless defined $atyp;
    unless($ver==5) {
	$self->{errortext} = "socks version $ver after connect? (should be 5)";
	return;
    }
=cut
	     o  X'00' succeeded
             o  X'01' general SOCKS server failure
             o  X'02' connection not allowed by ruleset
             o  X'03' Network unreachable
             o  X'04' Host unreachable
             o  X'05' Connection refused
             o  X'06' TTL expired
             o  X'07' Command not supported
             o  X'08' Address type not supported
=cut

    unless($rep==0) {
	if   ($rep==-1){ $self->{errortext} = "SOCKS5 server suddenly disconnected"; }
	elsif($rep==1){ $self->{errortext} = "general SOCKS5 server failure"; }
	elsif($rep==2){ $self->{errortext} = "SOCKS5 connection not allowed by ruleset"; }
	elsif($rep==3){ $self->{errortext} = "Network unreachable"; }
	elsif($rep==4){ $self->{errortext} = "Host unreachable"; }
	elsif($rep==5){ $self->{errortext} = "Connection refused"; }
	elsif($rep==6){ $self->{errortext} = "TTL expired"; }
	elsif($rep==7){ $self->{errortext} = "SOCKS5 Command not supported"; }
	elsif($rep==8){ $self->{errortext} = "SOCKS5 Address type not supported"; }
	else{ $self->{errortext} = "SOCKS5 reply $rep?"; }
	return;
    }

    $self->{bindip}   = inet_ntoa(pack("L",$bnd));
    $self->{bindport} = $bndp;

    $self->{state} = undef; # finish negotiation
}

sub es_oneround_noauth($);
sub es_oneround_userauth($);

sub establishsocks_init_oneround($) {
    my $self = shift;
    my $so = $self->{so};
    my $user = $self->{souser};
    my $password = $self->{sopassword};

    $self->{oneround}=1;
    unless ($self->{souser}) {
	print $so pack("CCC", 5, 1, 0);
	print $so pack("CCCC", 5, 1, 0, 1).inet_aton($self->{destip}).pack("n", $self->{destport});
        $self->{state} = \&es_noauth;
    } else {
	print $so pack("CCC", 5, 1, 2); 
	print $so pack("CC", 1, length($user)) . $user . pack("C", length($password)) . $password;
	print $so pack("CCCC", 5, 1, 0, 1).inet_aton($self->{destip}).pack("n", $self->{destport});
	$self->{state} = \&es_userauth;
    }
}
